h1. PlayRythm User Guide

PlayRythm provides an alternative template processing engine for Play!Framework. The template engine uses Java as an expression language. A powerful tag system allows you to create reusable functions.

Templates are stored in @app/rythm@ directory, -user defined tags are stored in @app/views/tags/rythm@ directory by default-.

p(note). Unlike groovy engine, there is no special place for tag file storage. Basically every template can be "invoked as a tag":#invoke_tag.

h2. <a name="syntax">Template Syntax</a>

A template file is a text file, some parts of which have placeholders for dynamically generated content. The templateâ€™s dynamic elements are written using the Java language.

Dynamic elements are resolved during template execution. The rendered result is then sent as part of the HTTP response.

p(note). All template elements are started with the '@' caret.

If you want to output a literal "<code>@</code>" character, you need to double it. E.g.

bc. This is an email address in template: someone@@gmail.com

h3. <a name="comment">Comments</a>

one line comment start with <code>@//</code>

bc. @// this is one line comment

multiple lines comment are put inside <code>@ * * @</code> block. yes it is the same as the new scala template

bc. @*
    this is a multiple line comment.
    The text inside this block will be ignore by Rythm template processor
*@

h3. <a name="expression">Expressions</a>

bc. @user.name @// evaluate user's name property and print it out
@user.getName(), @// call a method on an object and print out the result

The bracket "( )" can be used to compose complicated expressions or to separate an expression from other part of the template:

bc. @(1 + 5) @// print out the result of 1 + 5
@(user.name)_and_some_other_string @// use ( ) to separate expression from other part of the template

h4. <a name="escape">Escape an expression</a>

-Unlike Groovy template which all expressions are escaped by default, Rythm template won't do that due to performance concern. You must explicitly call @escape@ java object extension to escape the variable:-

Start from v0.9.8, PlayRythm escape expressions automatically as html format if the template file name suffix is ".html". To output an expression by raw data, one can do:

bc. @myVar.raw()

If you have a block of code that you would like to turn of the default escape behavior, you can use

bc. @raw() {
    echo @myVar @// this will not be escaped
}

In addition to HTML escape, PlayRythm provides escape to the following format as well:

# @CSV@: escape as csv format
# @JS/JavaScript@: escape as javascript format
# @Java@: escape as Java format
# @XML@: escape as XML format

And the user can use to these format like follows:

bc. @escape("XML") {
 <a><b>foo</b></a>
}

You can also use JavaExtensions to escape variable directly

bc. @myVar.escapeCsv()

h3. <a name="call_build-in_function">Call built-in function</a>

"@" is also used to invoke built-in functions. Built-in function could be treated as special type of tags. From the user's perspective there is no difference between calling a built-in function and calling a tag (either built-in or custom)

bc. @// indicate this template extends "/main.html" template
@extends(/main.html)
@// declare the java package/classes needed in this template
@import play.util.*, play.templates.*
@// declare arguments used in this template
@args String name, int score
@// output some information for debugging purpose
@debug("the variable is %s", someVariable)

There are about a dozen of built-in functions defined in Rythm, please go to "Reference":reference for details

h3. <a name="call_tag">Call user defined tag</a>

Again "@" can be used to call a user defined tag:

bc. @greenscript("app<jqueryui<jquery", all:true)

See "Tag invocation"#invoke_tag for detail.

h3. <a name="nameconflict">Tag or expression?</a>

Because Rythm template engine use the same caret <code>@</code> for both expression evaluation and tag invocation, there might be name conflict between invoking a tag and evaluating an expression. However in most cases this conflict could avoid. Suppose you have a tag file named @hello.html@, and you have a template defined with @hello@ variable declared:

bc. @args String hello;
@hello  @// this will evaluate the hello variable
@hello() @// this will invoke hello tag

But consider another case, when you have a tag file @hello.html@ defined in a folder named @who@, and you happened to have a variable named @who@ in a type @Who@ which has a method named @hello@, then

bc. @args Who who
@who.hello() @// name conflict happened here!

In the above code, rythm will not evaluate the method @hello@ of variable @who@, instead the @who.hello@ tag is invoked.

h3. <a name="scripting">Scripting</a>

Use <code>@{...}</code> to include arbitrary java source code into your template:

bc. @{
    String fullName = client.name.toUpperCase() + " " + client.forname;
}
<h1>Client @fullName</h1>

A script can write dynamic content directly using @p()@ function:

bc. @{
    String fullName = client.name.toUpperCase() + " " + client.forname;
    p("<h1>").p(fullName).p("</h1>");
}

Bear in mind that a template is not a place to do complex things. So, use a tag when you can, or move the computations into the controller or the model object.

h2. <a name="invoke_tag">Tag invocation</a>

**Tag** is a powerful tool to reuse your template definition in Rythm. To invoke a tag, use '@' plus tag name and brace pair

bc. @greenscript.js("app<jqueryui<jquery", all:true)
@verbatim() {
    the content within verbatim body will not get parsed by Rythm
    @foo.bar()
}

p(note). You must append @()@ to tag name even it does not require any parameter. The only exception to this rule is <a href="reference#return"><code>@return</code></a>, <a href="reference#break"><code>@break</code></a> and <a href="reference#continue"><code>@continue</code></a>. Because all three are Java reserved words and one cannot use them for variable/method names.

h3. <a name="call_tag_relative_path">Call tag using relative and import path</a>

Start from v0.9.8 you were able to invoke tag use relative path and import path. So suppose you have the following file system structure:

bc. \---app
    \---rythm
        |   tag1.html
        |
        +---Application
        |   |   index.html
        |   |   tagA.html
        |   |
        |   \---bar
        |           tagB.html
        |
        \---foo
            |   tag2.html
            |
            \---zee
                    tag3.html

Now inside your @app/rythm/Application/index.html@, you call those tags like follows:

bc. @Application.tagA() @// full path invocation
@Application.bar.tagB() @// full path invocation
@tagA() @// relative path invocation
@bar.tagB() @// relative path invocation

You can also save typing by using <code>@import</code> path:

bc. @import foo.*
@foo.tag2() @// full path invocation
@foo.zee.tag3() @// full path invocation
@tag2() @// import path invocation
@zee.tag3() @// import path invocation

h3. <a name="pass_parameter_to_tag">Passing arguments to tag</a>

Suppose you have defined a tag file hello.html:

bc. @args String title, String who;
Hello @title @who

And in another template you want to invoke hello.html. Like groovy template, you can pass an argument to a tag by name:

bc. @hello(title = "Mr.", who = "Green")

or this is also good:

bc. @hello(title: "Mr.", who: "Green")

Unlike groovy template, you are free to pass arguments to tag by position in Rythm template:

bc. @hello("Mr.", "Green)

p(note). "Controller action invocation":#invoke_action is a special kind of tag invocation. However you should NOT pass arguments by name when you invoke a controller action, instead *always pass argument by position when you invoke a controller action*

h3. <a name="invoke_tag_with_body">Call a tag with body</a>

To invoke tag with a body, just use the common @{ }@ to include the body content:

bc. @greenscript.js() {
    $(function(){
        // do whatever needed
    })
}

h3. <a name="tag_invocation_cache">Cache tag invocation result</a>

Start from v0.9.8 you can cache tag invocation result easily

bc. @myTag(1, 2, "3").cache() @// cache using default TTL, which is 1 hour
@myTag(1, 2, "3").cache("1h") @// cache invocation result for 1 hour
@myTag(1, 2, "3").cache(60 * 60) @// cache invocation result for 1 hour

The above statement invoke tag @myTag@ using parameter [1, 2, "3"] and cache the result for one hour. Within the next one hour, the tag will not be invoked, instead the cached result will be returned if the parameter passed in are still [1, 2, "3"].

So you see Rythm is smart enough to cache tag invocation against tag name and the parameter passed in. If the tag has body, the body will also be taken into consideration when calculating the cache key.

In some cases where the tag invocation result is not merely a function of the tag, parameter and body, but also some implicit variables, where you might expect different result even you have completely the same signature of tag invocation. Rythm provide way for you to take those additional implicit variable into account when calculating the cache key:

bc. @{User user = User.current()}
@myTag(1, 2, "3").cache("1h", user.isAdmin())

The above statement shows how to pass additional parameter to cache extention.

p(note). Also refer to <a href="reference#cache">@cache</a> keyword for more on cache parameters

h3. <a name="dynamic_tag_invocation">Dynamic tag invocation</a>

Dynamic tag invocation means the tag to be invoked is determined by a runtime variable, in this case, one can use <code>@invoke</code> keyword as shown below:

bc. @args String platform @// could be pc, iphone, ipad ...
...
@invoke("designer." + platform)

So when @platform@ is iphone, the above case has the same effect as calling <code>@designer.iphone()</code>.

Usually when a tag been invoked cannot be found, Rythm will report an error. Sometimes it is expected that certain template/tag does not exists, in which case one can use @.ignoreNonExistsTag()@ extension with <code>@invoke@</code> keyword:

p(note). <a href="call_tag_relative_path">Relative path/import path invocation</a> and <a href="tag_invocation_cache">cache</a> features also available to <code>@invoke</code> tag invocation

bc. @invoke("designer." + platform).ignoreNonExistsTag()

h3. <a name="invoke_action">Invoke controller action method</a>

It's possible to invoke controller action method directly from within the template and fill the render result content in place:

bc. @controllers.MyPortal.welcomePanel()

The above statement will invoke the controller <code>@controller.MyPortal</code>'s action method @welcomePanel@, and fill the render result content in place of the statement

<a name="invoke_action_cache"></a>

p(note). Because controller action invocation are treated as tag invocation, therefore caching tag invocation result also applies to controller action invocation. Please refer to "Cache tag invocation result":user_guide#tag_invocation_cache for details

p(note). See "integration guide":integration#action for more detail about invoking controller action method

h2. <a name="include">Include other templates</a>

Rythm support include other template inline:

bc. @include("foo.bar")

The above statement will put the content of template @foo.bar@ in place. "foo.bar" is translate into file name following "tag invocation":#call_tag_relative_path convention.

The difference between <code>@include("foo.bar")</code> a tag and call the tag via <code>@foo.bar()</code> is the former put the content of the template into the current template inline, while the latter invoke the template specified. It is some how like @#include@ vs. function call in c language. <code>@include</code> is super fast to reuse part of template because it suppress the function invocation at runtime. It's a **inline** function call if you speak c++.

Things you can achieve with <code>@include</code> but not tag invocation:

* Reuse "inline tag":inline_tag definition

Things you can achieve with tag invocation but not <code>@include</code>

* "Passing parameters":#pass_parameter_to_tag
* Layout management via "template inheritance":#inheritance

p(note). If you switch tag invocation to <code>@include</code> and found something has changed even there is no parameter call it might because you have <code>@extended</code> layout template in the tag template. <code>include</code> will NOT be able to include the layout template parts

p(note). Because <code>@include</code> are parsed at compile time therefore it's not possible to include template dynamically as shown below:

bc. @// spec could be one of facebook, google
@args String spec
@include("page." + spec) //@ THIS WON'T WORK
@{
    p(Rythm.render("path/to/page/" + spec + ".html") // THIS WORKS!
}


h3. <a name="reuse_inline_tag">Reuse inline tag across multiple views</a>

A good feature provided with <code>@include</code> is that you can import the "inline tag":#inline_tag definition from the template been included into the current template:

Suppose you have created a template named @app/rythm/util.html@ with a set of inline tags:

bc. @tag hi (String who) {
    Hi @who
}
@tag bye (String who) {
    Bye @who
}

Now in your normal template you can import all the inline tags [hi, bye] and call them like a local function:

bc. @include("util")
@hi("rythm")
@bye("rythm")

p(note). While <code>@tag</code> provides an alternative to "Helper":http://weblogs.asp.net/scottgu/archive/2011/05/12/asp-net-mvc-3-and-the-helper-syntax-within-razor.aspx in Razor, the <code>@include</code> provides an alternative to _*Reusing @helpers across multiple views*_. See Scott's "blog":http://weblogs.asp.net/scottgu/archive/2011/05/12/asp-net-mvc-3-and-the-helper-syntax-within-razor.aspx and search for "reusing @helpers across multiple views"

h2. <a name="inheritance">Template inheritance</a>

Template inheritance is a good way to implement template layout management.

bc. @// this type of extended template declaration is deprecated: @extends("main.html")
@extends("main")
<h1>Some code</h1>

The @main@ template is the layout template, you can use the @doLayout@ tag to include the content of the declaring template:

bc. <h1>Main template</h1>
<div id="content">
    @doLayout()
</div>

p(note). You can also use @renderBody@ in place of @doLayout@ to include the content, which comes from Razor. @render@ or @renderSection@ without parameter also does the same thing

h3. <a name="extended_template_path">Extended template lookup</a>

Before PlayRythm v0.9.8 you follow the same rule as groovy @#extends@ tag, i.e. you need to pass the full path to extended template file starting from @app/rythm@ folder: <code>@extends("main.html")</code>

Since v0.9.8 you have a clean and simple way to declare extended template, i.e. the way to declare a tag invocation. For example, if you want to extend @app/rythm/layout/foo/bar.html@, you can declare the extend statement as <code>@extends("layout.foo.bar")</code>.

The "relative path and include path declaration":user_guide#call_tag_relative_path feature are also available:

bc. @import layout.foo.*
@extends("bar")

See "Call tag using relative and import path":user_guide#call_tag_relative_path for more information on path lookup

p(note). Because extends are parsed statically you can omit the quotation mark when declaring extended templates:

bc. @extends(main)
@extends(layout.foo.bar)
@extends(main.html)
...

h3. Define section and output section

Like Razor, Rythm provides a section concept to enable you to define sections in sub templates and output them in parent template.

In your layout template, say @main.html@:

bc. <!DOCTYPE html>
<html>
<head>
...
</head>
<body>
  <div id="header">
    <h1>@get("title')</h1>
  </div>
  <div id="sidebar">
    @render("sidebar") @// render "sidebar" section
  </div>
  <div id="content">
    @render() @// render body, could also use @doLayout()
  </div>
  <div id="footer">
    <p>Site footer - &copy; Santa Clause</p>
  </div>
</body>
</html>

And in your parent template, say 'index.html':

bc. @extends(/main.html)
@set(title="Home page")
<h2>Welcome to my site</h2>
<p>This is our home page</p>
<p>Not super exciting is it?</p>
<p>Yada, Yada, Yada</p>
@section("sidebar") { @// define "sidebar" section
  <p>This sidebar has "Home Page" specific content</p>
  <ul>
    <li><a href="#">Link One</a></li>
    <li><a href="#">Link Two</a></li>
    <li><a href="#">Link Three</a></li>
  </ul>
}


h2. <a name="custom_tag">Create tags</a>

You can easily create specific tags for your application. A tag is a simple template file, stored in the @app/views/tags/rythm@ directory. The templateâ€™s file name is used as the tag name.

To create a @hello@ tag, just create the @app/views/tags/rythm/hello.html@ file.

bc. Hello from tag!

No need to configure anything. You can use the tag directly:

bc. @hello() @// the brace () is a must to call a tag

h3. Retrieve tag parameters

Tag parameters are exposed as template variables which declared using <code>@args</code> tag.

For example:

bc. @args String name;
Hello @name !

And you can pass the name parameter to the tag:

bc. @hello(name: "Bob")

or to pass parameter by position:

bc. @hello("Bob")

h3. <a name="callback_tag_body">Invoke tag body</a>

If your tag supports a @body@, you can include it at any point in the tag code, using the <code>@render()</code> keyword.

For example:

bc. Hello @render()!

And you can then pass the name as tag body:

bc. @hello() {
   Bob
}

h3. <a name="content-negotiation">Pickup tag file based on content format</a>

Like groovy template, you can have different versions of tag for different "content types":http://www.playframework.org/documentation/1.2.4/routes#content-types:

bc. // javascript code to request a html page
$.get("/ui/userManager", function(data) {
   $('#manager-panel').html(data);
})
// javascript code to request a JSON data
$.getJSON("/data/userList", function(data)) {
   model.users = ko.mapping.fromJS(data);
}

Suppose both request will result in a tag invocation <code>@user.list()</code> in the template code as below:

bc. //@ template code
@args List<User> users
...
@user.list()
...

When you have normal html page request, Rythm will try to look for @app/rythm/user/list.html@ file when doing the tag invocation. If the request is for a json data, Rythm will pickup @app/rythm/user/list.json@ first. If the preferred tag file cannot be found, then Rythm look for tag file for other formats in the following sequence:

# *.html
# *.json
# *.xml
# *.csv
# *.tag

h2. <a name="inline_tag">Define inline tags</a>

Rythm provides inline tag definition to achieve a lightweight and light speed reuse method in one template.

bc. @tag sayHello(String who, String title) {
  <p>Hello, @title @who</p>
}

And in the same template you can call the tag defined as usual:

bc. @for (User user: users) {
  @sayHello(user.name, user.title)
}

Inline tag definition is some how like "helper":http://weblogs.asp.net/scottgu/archive/2011/05/12/asp-net-mvc-3-and-the-helper-syntax-within-razor.aspx tool in Razor engine. With the <a href="#include"><code>@include</code></code></a> you can easily "reuse inline tag definition across multiple templates":#reuse_inline_tag

h2. <a name="java_tags">Custom Java tags</a>

Honestly creating Java tag is not so important in Rythm as it is in Groovy because Rythm template is running so fast that it is almost like a handwriting StringBuilder appended java code. However you might still want to do it because the logic in that tag is complicated and it is more easier to code in a Java source code than in a text template source.

There are 2 ways to creating Custom Java tags.

h3. <a name="fast_tags">The old Play FastTags approach</a>

PlayRythm provides a bridge to intercept a rythm tag call to FastTags call. So you are free to continue define FastTags as you did for Groovy template. See http://www.playframework.org/documentation/1.2.4/templates#fasttags for more details on how to create FastTags.

p(note). Developer cannot use all stuffs in FastTags. The constraints include @Closure@ parameter and @TagContext@ etc.

h3. <a name="rythm_java_tag">Implement Java Tag using Rythm's new Java Tag interface</a>

Another approach is to implement Java Tag using Rythm's new @com.greenlaw110.rythm.play.FastRythmTag@:

bc. import com.greenlaw110.rythm.play.FastRythmTag;
@play.templates.FastTags.Namespace("") // yes, you use the same Namespace annotation in Rythm Fast Tag definition
public class authenticityToken extends FastRythmTag {
    @Override public void call(ParameterList params, Body body) {
        p("<input type=\"hidden\" name=\"authenticityToken\" value=\"" + Scope.Session.current().getAuthenticityToken() + "\">");
    }
}

The above code shows how to implement Play's authenticityToken tag in Rythm.

h4. Pros and Cons of the two approach

The good side of FastTags approach is it's compatible to Groovy template, and thus should be welcome by module developers who don't need a PlayRythm copy to get their code compileds and distributed.

The only tiny problem with FastTags is that it uses reflection to lookup the method to be called, which might be a little bit more time consuming than using Rythm's tag interface

h2. <a name="java_extension">Java object extensions in templates</a>

Rythm template provides limited support for "Java object extensions":http://www.playframework.org/documentation/1.2.4/templates#extensions.

# You are allowed to use most Java object extensions defined in Play's @play.templates.JavaExtensions.
# Java object extensions can only be processed when they are in the end of an expression

bc. <ul>
@for(Product product: products) {
    <li>@product.name. Price: @product.price.format("## ###,00") â‚¬</li>
}
</ul>

The following expressions will not work because Java object extension ".escape()" is used in the middle of the expression.

bc. @(myVal.escape() + myVal2.toString())
@someString.escape().length()

However you can chain java object extensions like:

bc. @myVal.escape().capAll()

In the above expression, java object extension @capAll@ and @escape@ is chained together and both of they will be processed.

h3. Customized Java object extension

This is not supported at the moment but is a "planned feature":https://github.com/greenlaw110/play-rythm/issues/2.

h2. Implicit objects available in a template

Unlike Play's Groovy template that all objects added to the renderArgs scope are directly injected as template variables, you must declare them (and might need to import their class packages) to use them freely in your template. PlayRythm plugin automatically declare and set the following implicit objects so that you don't need to do these job before using them:

|| Variable || Description || API documentation || See also ||
| @errors@ | Validation errors | "play.data.validation.Validation.errors()":/@api/play/data/validation/Validation.html#errors%28%29 | "Validating HTTP data":validation |
| @flash@ | Flash scope | "play.mvc.Scope.Flash":/@api/play/mvc/Scope.Flash.html  | "Controllers - Session & Flash Scope":controllers#session |
| @lang@ | The current language (in java.lang.String) | "play.i18n.Lang":/@api/play/i18n/Lang.html | "Setting up I18N - Define languages":i18n#languages |
| @messages@ | The messages map | "play.i18n.Messages":/@api/play/i18n/Messages.html | "Setting up I18N - Externalize messages":i18n#messages |
| @params@ | Current parameters | "play.mvc.Scope.Params":/@api/play/mvc/Scope.Params.html  | "Controllers - HTTP parameters":controllers#params |
| @_play@ | Main framework class | "play.Play":/@api/play/Play.html |  |
| @request@ | The current HTTP request | "play.mvc.Http.Request":/@api/play/mvc/Http.Request.html  |  |
| @session@ | Session scope | "play.mvc.Scope.Session":/@api/play/mvc/Scope.Session.html  | "Controllers - Session & Flash Scope":controllers#session |
| @_response_encoding@ | encoding of the response object | "play.mvc.Http.Response":/@api/play/mvc/Http.Response.html | |
| @_rythmPlugin@ | the RythmPlugin instance | @com.greenlaw110.rythm.play.RythmPlugin@ | |
| @_rythm@ | the rythm template engine instance | @com.greenlaw110.rythm.RythmEngine@ | |

So as you can see most of these implicit variables are the same as those defined in "Groovy templates":http://localhost:9000/@documentation/modules/play/user_guide#Implicitobjectsavailableinatemplate. The only exception is Groovy's implicit variable @play@ has been renamed to @_play@. The reason for this is I want to allow user to use full qualified classes in play.* package.

p(note). If you have put something into your @RenderArgs@, and you didn't declare it using <code>@args</code> statement, you are still able to access it via @getRenderArg()@ method. But please be noted that all stuff you get via @getRenderArg()@ call are @Object@ type, and you need to explicitly cast them before accessing properties and methods of them:

bc. @(((User)getRenderArg("user")).getName())

h2. Implicit import statements

PlayRythm automatically insert the following import statements so that user can reference relevant classes without write manually <code>@import</code> statement:

# @java.util.*@
# @java.io.*@
# @controller.*@
# @models.*@
# @play.templates.JavaExtensions@

h2. <a name="resource">See also</a>

# "References manual":reference
# "Integrate PlayRythm into your Play project":integration
